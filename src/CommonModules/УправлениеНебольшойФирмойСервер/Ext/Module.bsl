
#Область ПрограммныйИнтерфейс

#Область Разное

// Устарела. Будет удалена в следующей версии программы. 
// См. ОбщегоНазначения.СообщитьПользователю
// Выводит сообщение об ошибке заполнения поля.
//
Процедура СообщитьОбОшибке(ОбъектСОшибкой, ТекстСообщения, ИмяТабличнойЧасти = Неопределено,
	НомерСтроки = Неопределено, Поле = Неопределено, Отказ = Ложь, МассивСообщений = Неопределено) Экспорт
	
	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщения;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		
		// Платформа 8.2.15
		
	Иначе
		
		Если ИмяТабличнойЧасти <> Неопределено Тогда
			Сообщение.Поле = ИмяТабличнойЧасти + "[" + (НомерСтроки - 1) + "]." + Поле;
		ИначеЕсли ЗначениеЗаполнено(Поле) Тогда
			Сообщение.Поле = Поле;
		КонецЕсли;
		
		Сообщение.УстановитьДанные(ОбъектСОшибкой);
		
	КонецЕсли;
	
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
	// Розница.ОтрицательныеОстатки
	Если МассивСообщений <> Неопределено Тогда
		МассивСообщений.Добавить(Новый Структура("Текст, Поле", Сообщение.Текст, Сообщение.Поле));
	КонецЕсли;
	
КонецПроцедуры

// Устарела. Будет удалена в следующей версии программы.
// См. Пользователи.ЭтоПолноправныйПользователь 
Функция ЭтоПолноправныйПользователь(Пользователь = Неопределено,
                                    ПроверятьПраваАдминистрированияСистемы = Ложь,
                                    УчитыватьПривилегированныйРежим = Истина) Экспорт
	
	Возврат Пользователи.ЭтоПолноправныйПользователь(Пользователь, ПроверятьПраваАдминистрированияСистемы,
		УчитыватьПривилегированныйРежим);
	
КонецФункции

#Область ЧтениеТекстовогоФайла

Функция ЕстьСимволыВНачалеСтроки(Строка, ПроверяемыеСимволы)
	
	Для Позиция = 1 По СтрДлина(ПроверяемыеСимволы) Цикл
		Символ = Сред(ПроверяемыеСимволы, Позиция, 1);
		СимволНайден = СтрНачинаетсяС(Строка, Символ) ИЛИ СтрЗаканчиваетсяНа(Строка, Символ);
		Если СимволНайден Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет строку на соответствие требованиям
//
// Параметры:
//  ПроверяемаяСтрока - Строка - проверяемый строка.
//
// Возвращаемое значение:
//  Булево - Истина, если ошибок нет.
//
Функция ТолькоСимволыВСтроке(Знач ПроверяемаяСтрока) Экспорт
	
	Если ПустаяСтрока(ПроверяемаяСтрока) Тогда
		Возврат Истина;
	КонецЕсли;
	
	// приводим строку к нижнему регистру
	ПроверяемаяСтрока = НРег(СокрЛП(ПроверяемаяСтрока));
	
	// допустимые символы
	СпецСимволы = ".,;:$№#@&_-+*=?'/|\""%()[]{} ";
	
	// проверяем наличие спецсимволов в начале или конце строке
	Если ЕстьСимволыВНачалеСтроки(Лев(ПроверяемаяСтрока, 1), СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// проверяем допустимые символы
	Если НЕ СтрокаСодержитТолькоДопустимыеСимволы(ПроверяемаяСтрока, СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(СтрокаПроверки, ДопустимыеСимволы)
	
	// Кириллица
	КодСимволаА = КодСимвола("а"); 
	КодСимволаЯ = КодСимвола("я");
	
	// Цифры
	КодСимвола0 = КодСимвола("0");
	КодСимвола9 = КодСимвола("9");
	
	// Латиница
	КодСимволаA = КодСимвола("a");
	КодСимволаZ = КодСимвола("z");
	
	// Спецсимволы
	КодыДопустимыхСимволов = Новый Массив;
	Для Индекс = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		Символ = Сред(ДопустимыеСимволы, Индекс, 1);
		КодыДопустимыхСимволов.Добавить(КодСимвола(Символ));
	КонецЦикла;
	
	КодыДопустимыхСимволов.Добавить(1105); // "ё"
	
	// Проверяем каждым символ в строке
	// допустим ли он.
	Для Индекс = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодПроверяемогоСимвола = КодСимвола(Сред(СтрокаПроверки, Индекс, 1));
		ЭтоДопустимыйСимвол = 
			КодСимволаА <= КодПроверяемогоСимвола И КодПроверяемогоСимвола <= КодСимволаЯ     // Кириллица
			ИЛИ КодСимволаA <= КодПроверяемогоСимвола И КодПроверяемогоСимвола <= КодСимволаZ // Латиница
			ИЛИ КодСимвола0 <= КодПроверяемогоСимвола И КодПроверяемогоСимвола <= КодСимвола9 // Цифры
			ИЛИ КодыДопустимыхСимволов.Найти(КодПроверяемогоСимвола) <> Неопределено;         // Спецсимволы и ё
			
		Если НЕ ЭтоДопустимыйСимвол Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Функция возвращает тип файла после прочтения первых 5 строк
// Определяем кодировку
Функция ТипФайла(ИмяФайла)
	
	Текст              = Новый ЧтениеТекста(ИмяФайла, "windows-1251");
	СтрокаТекста       = Текст.ПрочитатьСтроку();
	НомерТекущейСтроки = 0;
	
	Пока СтрокаТекста <> Неопределено Цикл
		// Проверяем кодировку файла
		Если НомерТекущейСтроки = 0 И НЕ ТолькоСимволыВСтроке(СтрокаТекста) Тогда // UTF-8.
			Возврат "UTF-8";
		ИначеЕсли НЕ ТолькоСимволыВСтроке(СтрокаТекста) Тогда
			Возврат "cp866";
		КонецЕсли;
		// Читаем первые пять строк, этого должно быть достаточно,
		// чтобы определить кодировку
		Если НомерТекущейСтроки > 5 Тогда 
			Прервать;
		КонецЕсли;
		НомерТекущейСтроки = НомерТекущейСтроки + 1;
		СтрокаТекста       = Текст.ПрочитатьСтроку();
	КонецЦикла;
	
	Возврат "windows-1251";
	
КонецФункции

// Возвращаемое значение:
//   Структура   - Ключи структуры:
//                   ТекстФайла
//                   КоличествоСтрокВФайле
Функция ПолучитьТекстФайлаНаВебКлиентеФрагмент(АдресВременногоХранилища, ДополнительныеПараметры, ОдиночныйРазделительСтрок = Ложь) Экспорт
	
	СтруктураДляВозврата = Новый Структура(
		"ТекстФайла, КоличествоСтрокВФайле, БылоИсключение",
		"", 0, Ложь);
	
	ИмяФайла  = ПолучитьИмяВременногоФайла("txt");
	ДвоичныеДанныеФайла = ПолучитьИзВременногоХранилища(АдресВременногоХранилища);
	ДвоичныеДанныеФайла.Записать(ИмяФайла);
	
	Кодировка = ДополнительныеПараметры.Кодировка;
	
	Попытка
		
		// Тип файла передаем в виде строки, чтобы обеспечить корректное чтение файла в нелокализованных средах
		// (Linux, англоязычная Windows + англоязычный MS SQL и др.)
		Если Кодировка = Неопределено ИЛИ Кодировка = "Авто" Тогда
			ТипФайла = ТипФайла(ИмяФайла);
		ИначеЕсли (Кодировка = КодировкаТекста.OEM) ИЛИ (Кодировка = "DOS") Тогда
			ТипФайла = "cp866";
		ИначеЕсли ДополнительныеПараметры.Кодировка = "Windows" ИЛИ НЕ ЗначениеЗаполнено(ДополнительныеПараметры.Кодировка) Тогда
			ТипФайла = "windows-1251";
		Иначе
			ТипФайла = ДополнительныеПараметры.Кодировка;
		КонецЕсли;
		
		Если ТипФайла = "cp866" Тогда
			ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, ТипФайла,,,Ложь);
		Иначе
			// Если в файле строки разделены CR+LF, то одиночные LF не разделяют логические строки файла, а содержится в прикладных данных.
			// При этом в отдельных полях (многострочных) они разделяют подстроки,
			// а в остальных, как правило, содержатся по ошибке и должны быть проигнорированы.
			//
			// Чтобы отличить ошибочные одиночные LF от корректных разделителей CR+LF,
			// при чтении файла используем только двухсимвольный разделитель (CR+LF),
			// а если необходимо избавиться от ошибочных LF (Символы.ПС), то делаем это после чтения строк (перед помещением
			// данных в Секция.Данные).
			//
			// Если же в файле строки разделены одиночным LF, то отличить ошибочные LF от корректных нельзя.
			// Поэтому при чтении файла используем обычный набор разделителей. При этом ошибочно отделенные элементы строк могут
			// быть проигнорированы.
			ДвухсимвольныйРазделительСтрок = Символы.ВК + Символы.ПС;
			Если ОдиночныйРазделительСтрок Тогда
				// Значения по умолчанию. В конструктор их следует передать явно, так как значение пятого параметра указано явно.
				РазделительСтрок               = Символы.ПС;
				КонвертируемыйРазделительСтрок = ДвухсимвольныйРазделительСтрок;
			Иначе
				РазделительСтрок               = ДвухсимвольныйРазделительСтрок;
				КонвертируемыйРазделительСтрок = "";
			КонецЕсли;
			ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, ТипФайла, РазделительСтрок, КонвертируемыйРазделительСтрок, Ложь);
		КонецЕсли;
		
	Исключение
		
		Сообщить(ОписаниеОшибки());
		СтруктураДляВозврата.БылоИсключение = Истина;
		Возврат СтруктураДляВозврата;
		
	КонецПопытки;
	
	ВремТекстовыйДокумент = Новый ТекстовыйДокумент;
	КоличествоСтрокВФайле = 0;
	
	Пока Истина Цикл
		
		ТекстСтрокиФайла = ЧтениеТекста.ПрочитатьСтроку();
		
		Если ТекстСтрокиФайла = Неопределено Тогда 
			Прервать;
		КонецЕсли;
		
		ВремТекстовыйДокумент.ДобавитьСтроку(СтрЗаменить(ТекстСтрокиФайла, Символы.ПС, " "));
		КоличествоСтрокВФайле = КоличествоСтрокВФайле + 1;
		
	КонецЦикла;
	
	СтруктураДляВозврата.ТекстФайла = ВремТекстовыйДокумент.ПолучитьТекст();
	СтруктураДляВозврата.КоличествоСтрокВФайле = КоличествоСтрокВФайле;
	
	Возврат СтруктураДляВозврата;
	
КонецФункции

#КонецОбласти

// Функция возвращает дату запрета ЕНВД.
Функция ДатаОтменыЕНВД() Экспорт
	
	Возврат '20210101';
	
КонецФункции

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  Коэффициенты - Массив - коэффициенты распределения;
//  Точность - Число - точность округления при распределении. Необязателен.
//
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//           или суммарный вес коэффициентов = 0), тогда возвращается значение Неопределено.
//
Функция РаспределитьПропорционально(Знач РаспределяемаяСумма, Знач Коэффициенты, Знач Точность = 2) Экспорт

	Если Коэффициенты.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	РаспределеннаяСумма = 0;
	СуммаКоэффициентов  = 0;
	
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Коэффициент = Коэффициенты[Индекс];
		
		АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, -Коэффициент);
		Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
			МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	
	Если СуммаКоэффициентов = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив(Коэффициенты.Количество());
	
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	
	Дельта = РаспределяемаяСумма - РаспределеннаяСумма;
	
	Если Дельта > 0 Тогда 
		
		// Погрешности округления отнесем на коэффициент с максимальным весом.
		Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
			Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + Дельта;
		КонецЕсли;
		
	ИначеЕсли Дельта < 0 Тогда 
		
		// Если распределили больше чем положено, размазываем погрешность по ближайшим максимальным весам.
		ЗначениеПогрешности = 1 / Pow(10, Точность);
		КоличествоЭлементовПогрешности = -Дельта / ЗначениеПогрешности;
		
		КоэффициентыРешето = Новый Массив(Новый ФиксированныйМассив(Коэффициенты));
		
		Для Сч = 1 По КоличествоЭлементовПогрешности Цикл 
			МаксимальныйКоэффициент = МаксимальноеЗначениеВМассиве(КоэффициентыРешето);
			Индекс = КоэффициентыРешето.Найти(МаксимальныйКоэффициент);
			Результат[Индекс] = Результат[Индекс] - ЗначениеПогрешности;
			КоэффициентыРешето[Индекс] = 0;
		КонецЦикла;
		
	Иначе 
		// Если Дельта = 0, то все идеально.
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Функция МаксимальноеЗначениеВМассиве(Массив)
	
	// Рассчитываем, что на вход будет получен массив, в котором все элементы либо все положительные, либо отрицательные.
	// Поэтому для определения максимального значения сравниваем абсолютное значение элемента.
	//
	// В случае, если на вход получен массив, в котором элементы с разными знаками, то максимальное значение будет
	// определено не правильно. Но этот случай оставлен для совместимости с предыдущими версиями.
	
	МаксимальноеЗначение = 0;
	Множитель            = 1;
	Для Индекс = 0 По Массив.Количество() - 1 Цикл
		Значение = Массив[Индекс];
		АбсолютноеЗначение = ?(Значение> 0, Значение, -Значение);
		Если МаксимальноеЗначение < АбсолютноеЗначение Тогда
			МаксимальноеЗначение = АбсолютноеЗначение;
			Множитель = ?(Значение > 0, 1, -1);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальноеЗначение * Множитель;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыФормированияДвиженийРегистров

// Выполняет движения регистра накопления ПрослеживаемыеТовары.
//
Процедура ОтразитьПрослеживаемыеТовары(ДополнительныеСвойства, Движения, Отказ) Экспорт
	
	ТаблицаПрослеживаемыеТовары = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаПрослеживаемыеТовары;
	
	Если Отказ
	 ИЛИ ТаблицаПрослеживаемыеТовары.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияПрослеживаемыеТовары = Движения.ПрослеживаемыеТовары;
	ДвиженияПрослеживаемыеТовары.Записывать = Истина;
	ДвиженияПрослеживаемыеТовары.Загрузить(ТаблицаПрослеживаемыеТовары);
	
КонецПроцедуры // ОтразитьЗапасыНаСкладах()

#КонецОбласти

#Область ПроцедурыИФункцииФормирующиеТекстыСообщенийОбОшибкахПроведения

// Устарела. Будет удалена в следующей версии программы.
// См. Справочники.Номенклатура.Представление
// Формирует строку представления номенклатуры с учетом характеристики и серий.
//
// Параметры:
//  НоменклатураПредставление - Строка - представление номенклатуры.
//  ХарактеристикаПредставление - Строка - представление характеристики.
//  ПартияПредставление - Строка - представление партии.
//
// Возвращаемое значение:
//  Строка - строка с представлением номенклатуры.
//
Функция ПредставлениеНоменклатуры(НоменклатураПредставление,
	                              ХарактеристикаПредставление  = "",
	                              ПартияПредставление          = "",
								  ЗаказПокупателяПредставление = "") Экспорт
	
	Возврат Справочники.Номенклатура.Представление(НоменклатураПредставление, ХарактеристикаПредставление,
		ПартияПредставление, ЗаказПокупателяПредставление);
	
КонецФункции

// Устарела. Будет удалена в следующей версии программы.
// См. РегистрыСведений.ДокументыФизическихЛиц.ПолучитьПредставлениеДокументаПоФизЛицу
// Функция возвращает паспортные данные физического лица строкой, используемые
// в печатных формах.
//
// Параметры
//  СтруктураДанных - Структура - ссылка на ФизЛицо и дата
//                 
// Возвращаемое значение:
//   Строка      - Строка, содержащая паспортные данные
//
Функция ПолучитьПаспортныеДанныеСтрокой(СтруктураДанных) Экспорт

	Если НЕ ЗначениеЗаполнено(СтруктураДанных.ФизЛицо) Тогда
		Возврат НСтр("ru = 'Отсутствуют данные об удостоверении личности.'");
	КонецЕсли; 
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	                      |	ДокументыФизическихЛицСрезПоследних.ВидДокумента,
	                      |	ДокументыФизическихЛицСрезПоследних.Серия,
	                      |	ДокументыФизическихЛицСрезПоследних.Номер,
	                      |	ДокументыФизическихЛицСрезПоследних.КемВыдан,
	                      |	ДокументыФизическихЛицСрезПоследних.КодПодразделения,
	                      |	ДокументыФизическихЛицСрезПоследних.ДатаВыдачи КАК ДатаВыдачи
	                      |ИЗ
	                      |	РегистрСведений.ДокументыФизическихЛиц.СрезПоследних(
	                      |			&НаДату,
	                      |			Физлицо = &Физлицо
	                      |				И ЯвляетсяДокументомУдостоверяющимЛичность) КАК ДокументыФизическихЛицСрезПоследних");
	
	Запрос.УстановитьПараметр("НаДату", СтруктураДанных.Дата);
	Запрос.УстановитьПараметр("Физлицо", СтруктураДанных.ФизЛицо);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат НСтр("ru = 'Отсутствуют данные об удостоверении личности.'");
	Иначе
		ПаспортныеДанные = РезультатЗапроса.Выгрузить()[0];
		ВидДокумента       = ПаспортныеДанные.ВидДокумента;
		Серия              = ПаспортныеДанные.Серия;
		Номер              = ПаспортныеДанные.Номер;
		ДатаВыдачи         = ПаспортныеДанные.ДатаВыдачи;
		КемВыдан           = ПаспортныеДанные.КемВыдан;
		НомерПодразделения = ПаспортныеДанные.КодПодразделения;
		
		Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
			И НЕ ЗначениеЗаполнено(ВидДокумента)
			И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан + НомерПодразделения)) Тогда

			СтрокаПаспортныеДанные = НСтр("ru = '%ВидДокумента% Серия: %Серия%, № %Номер%, Выдан: %ДатаВыдачи% года, %КемВыдан%; № подр. %НомерПодразделения%'");
			
			СтрокаПаспортныеДанные = СтрЗаменить(СтрокаПаспортныеДанные, "%ВидДокумента%", ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", "));
			СтрокаПаспортныеДанные = СтрЗаменить(СтрокаПаспортныеДанные, "%Серия%", Серия);
			СтрокаПаспортныеДанные = СтрЗаменить(СтрокаПаспортныеДанные, "%Номер%", Номер);
			СтрокаПаспортныеДанные = СтрЗаменить(СтрокаПаспортныеДанные, "%ДатаВыдачи%", Формат(ДатаВыдачи,"ДЛФ=DD"));
			СтрокаПаспортныеДанные = СтрЗаменить(СтрокаПаспортныеДанные, "%КемВыдан%", КемВыдан);
			СтрокаПаспортныеДанные = СтрЗаменить(СтрокаПаспортныеДанные, "%НомерПодразделения%", НомерПодразделения);
			
			Возврат СтрокаПаспортныеДанные;

		Иначе
			Возврат НСтр("ru = 'Отсутствуют данные об удостоверении личности.'");
		КонецЕсли;
	КонецЕсли;

КонецФункции

#КонецОбласти

#Область ПроцедурыВыдачиСообщенийОбОшибкахПроведения

// Устарела. Будет удалена в следующей версии программы.
// См. КонтрольОстатковУНФ.Запасы
Процедура СообщитьОбОшибкахПроведенияПоРегиструЗапасы(ДокОбъект, ВыборкаЗаписей, Отказ, МассивСообщений = Неопределено) Экспорт
	КонтрольОстатковУНФ.Запасы(ДокОбъект, ВыборкаЗаписей, Отказ);
КонецПроцедуры

// Устарела. Будет удалена в следующей версии программы.
// См. КонтрольОстатковУНФ.ЗапасыВРазрезеГТД
Процедура СообщитьОбОшибкахПроведенияПоРегиструЗапасыВРазрезеГТД(ДокОбъект, ВыборкаЗаписей, Отказ) Экспорт
	КонтрольОстатковУНФ.ЗапасыВРазрезеГТД(ДокОбъект, ВыборкаЗаписей, Отказ);
КонецПроцедуры

// Процедура сообщает об ошибках проведения по регистру Прослеживаемые товары.
//
Процедура СообщитьОбОшибкахПроведенияПоРегиструПрослеживаемыеТовары(ДокОбъект, ВыборкаЗаписей, Отказ, МассивСообщений = Неопределено) Экспорт
	
	ЗаголовокОшибки = НСтр("ru = 'Ошибка:'");
	ТекстЗаголовкаСообщения = ЗаголовокОшибки + Символы.ПС + НСтр("ru = 'Не хватает остатка по учету прослеживаемых товаров'");
	
	ШаблонСообщения = НСтр("ru = 'Номенклатура: %НоменклатураХарактеристикаПартия% (%СтранаПроисхождения%),
		|РНПТ: %РНПТ%'");
	ШаблонКоличества = НСтр("ru = 'остаток %КоличествоОстаток% %ЕдиницаИзмерения%,
		|недостаточно %КоличествоНехватка% %ЕдиницаИзмерения%'");
	ШаблонКоличестваПрослеживаемости = НСтр("ru = 'остаток прослеживаемости %КоличествоПрослеживаемостиОстаток% %ЕдиницаИзмеренияПрослеживаемости%,
		|недостаточно %КоличествоПрослеживаемостиНехватка% %ЕдиницаИзмеренияПрослеживаемости%'");
	
	ВыводитьВЗаголовокРасшифровку = Истина;
	Пока ВыборкаЗаписей.Следующий() Цикл
		
		Если ВыводитьВЗаголовокРасшифровку Тогда
			СообщитьОбОшибке(ДокОбъект, ТекстЗаголовкаСообщения, , , , Отказ, МассивСообщений);
			ВыводитьВЗаголовокРасшифровку = Ложь;
		КонецЕсли;
		
		ПредставлениеНоменклатуры = ПредставлениеНоменклатуры(ВыборкаЗаписей.НоменклатураПредставление, ВыборкаЗаписей.ХарактеристикаПредставление, ВыборкаЗаписей.ПартияПредставление);
		ТекстСообщения = ШаблонСообщения;
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НоменклатураХарактеристикаПартия%", ПредставлениеНоменклатуры);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%СтранаПроисхождения%", ВыборкаЗаписей.СтранаПроисхожденияПредставление);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%РНПТ%", ВыборкаЗаписей.РНПТПредставление);
		
		Если ВыборкаЗаписей.ОстатокКоличествоТекущий < 0 Тогда
			ТекстСообщения = СтрШаблон("%1,
				|%2", ТекстСообщения, ШаблонКоличества);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОстаток%", Строка(ВыборкаЗаписей.ОстатокКоличество));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоНехватка%", Строка(-ВыборкаЗаписей.ОстатокКоличествоТекущий));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ЕдиницаИзмерения%", СокрЛП(ВыборкаЗаписей.ЕдиницаИзмеренияПредставление));
		КонецЕсли; 
		
		Если ВыборкаЗаписей.ОстатокКоличествоПрослеживаемостиТекущий < 0 Тогда
			ТекстСообщения = СтрШаблон("%1,
				|%2", ТекстСообщения, ШаблонКоличестваПрослеживаемости);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоПрослеживаемостиОстаток%", Строка(ВыборкаЗаписей.ОстатокКоличествоПрослеживаемости));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоПрослеживаемостиНехватка%", Строка(-ВыборкаЗаписей.ОстатокКоличествоПрослеживаемостиТекущий));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ЕдиницаИзмеренияПрослеживаемости%", СокрЛП(ВыборкаЗаписей.ЕдиницаИзмеренияПрослеживаемостиПредставление));
		КонецЕсли; 
		
		СообщитьОбОшибке(ДокОбъект, ТекстСообщения, , , , Отказ, МассивСообщений);
		
	КонецЦикла;
	
КонецПроцедуры // СообщитьОбОшибкахПроведенияПоРегиструПрослеживаемыеТовары()

#КонецОбласти

#Область Ценообразование

// Устарела. Будет удалена в следующей версии программы.
// См. ЦенообразованиеСервер.ПересчитатьИзВалютыВВалюту
Функция ПересчитатьИзВалютыВВалюту(Сумма, КурсНачальный, КурсКонечный,	КратностьНачальная = 1, КратностьКонечная = 1) Экспорт
	
	Возврат ЦенообразованиеСервер.ПересчитатьИзВалютыВВалюту(Сумма, КурсНачальный, КурсКонечный, КратностьНачальная, КратностьКонечная);
	
КонецФункции // ПересчитатьИзВалютыВВалюту()

#КонецОбласти

#КонецОбласти
